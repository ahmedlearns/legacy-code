<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Working with Legacy Code

---

# Notes

slides branches example: `slides/1` or `slides/what-is-legacy-code`

demo code under `src/` branches: `demo/1.0`, `demo/1.1`, `demo/2.0`, etc

???
These are more notes

---

class: center

# What is Legacy Code?

<img src="https://i.imgur.com/1r2x3C6.jpg" width="250"/>

--

Code we've gotten from someone else

--

Code that hasn't been touched in living memory

--

Code you're afraid to touch


--

Code written by someone who is no longer around

--

Code without tests

???
No matter how well written it is, pretty, objected-oriented, or well encapsulated it is. Without tests, we can't change the behavior of our code quickly and verifiably. We can't be certain within a reasonable timeframe if our code is getting better or worse.

---

class: center

# Clean Code

<img src="https://i.imgur.com/igYy5Y5.png" width="250" />

--

Easy to understand

--

Easy to get under test

--

Easy to refactor

--

Easy to add features

---

class: center

# Changing Software

--

## Questions to ask yourself:

<br />

--

1. .left[What changes do we have to make?]

--

2. .left[How will we know that we've done them correctly?]

--

3. .left[How will we know that we haven't broken anything?]

--

4. .left[How much change can you afford if changes are risky?]

---

class: center, middle

# "If it's not broke, don't fix it."

???
It's tempting to think that we can minimize software problems and bugs by avoiding them, but, unfortunately, it always catches up with us.

Avoiding creating new classes and methods leads to giganto-hard-to-understand-and-modify systems.

---

class: center

# Two ways to change code

--

## Cover and Move

--

### and

## Edit and Pray

---

class: center

# Edit and Pray

--

<img src="https://energycentral.com/sites/default/files/styles/article_body/public/ece/nodes/355107/safety20net.png" width="450">

Industry standard?

???
Carefully plan changes <br />
Make sure you understand code <br />
Make the changes

---

class: center

# Cover and Move

--

<img src="https://www.huaxingnets.com/wp-content/uploads/2018/06/tech_safety_alpha.png" width="450" />


Work with a safety net.

???
Cover = cover with tests. <br />
We can make quick changes and find out very quickly if the effects were good or bad. <br />

---

class: center

# Software Vise

<br>

<img src="https://images-na.ssl-images-amazon.com/images/I/61A18RWrAmL._AC_SY450_.jpg" width="450">

**vise** *noun* a metal tool with movable jaws that are used to hold an object firmly in place while work is done on it, typically attached to a workbench.

???
Tests that detect change are like a vise around our code <br>
The behavior of the code is fixed in place <br>
Allowing us to be in more control of our work.

---

class: center

# The Legacy Code Dilemma

<img src="https://imgs.xkcd.com/comics/delicious.png" width="350">

--

???
In order to make changes easier, often we have to break dependencies <br>

--

When we change code, we should have tests in place.

To put tests in place, we often have to change code.

--

What do we do?

Ehh. Be careful. Use your refactoring tools.

---

class: center

# Working with Legacy Code

<img src="https://f4.bcbits.com/img/a0897681528_10.jpg" width="350">

--

= how do we break dependencies?

---

class: center

# (one) Legacy Code Change Algorithm


---

class: center

# What else can we do?

<br>

???
A broad test that covers a large swath of the application will help you notice if any of your changes break something.

Since you have finite time to spend writing tests, it is more important to get broad coverage than targeted coverage.

<br>

Usually TDD writes just enough test code to make the tests fail; then writes model code only until all tests pass.

When working with legacy code, the model code is mostly already written.

Not uncommon to write a lot of tests before switching back to model code.

--

Focus more on broad coverage than targeted coverage.

--

Write a lot of tests before you can write a little.

--

Already have some large tests? Can they be morphed into unit tests?



---

class: center

# Summing it Up

--

Some tests are better than none

--

Don't let the perfect be the enemy of good.



    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>